module Gamepad.Advanced
    exposing
        ( Blob
        , Model
        , Msg
        , UserMappings
        , animationFrameDelta
        , animationFrameTimestamp
        , emptyUserMappings
        , encodeUserMappings
        , getGamepads
        , init
        , onBlob
        , unmappedGamepads
        , update
        , userMappingsDecoder
        , userMappingsFromString
        , userMappingsToString
        , view
        )

{-| You should use this module only if you need more control than what `Gamepad.Simple` offers.

1.  Add the port code. See [Adding Ports](https://package.elm-lang.org/packages/xarvh/elm-gamepad/latest/#adding-ports) for how to do it.

2.  Decide how you want to persist the [UserMappings]. This module contains functions to help you encode and decode them.

3.  When your app inits, load the [UserMappings]. Default to [emptyUserMappings] if you can't load any.

4.  Decide where and when you want the remapping tool to appear within your app's UI.

5.  Add the remapping tool using the [Model], [Msg], [init], [update], [view] in this module.

6.  Every time [update] returns a function to update the [UserMappings], update them in your app's model and persist them.

7.  In your app's `subscriptions`, replace `Browser.Events.onAnimationFrame`/`Browser.Events.onAnimationFrameDelta` with

```
type TheAppMsg
    = OnRemappingToolMsg Gamepad.Advanced.Msg
    | ...

subscriptions : TheAppModel -> Sub TheAppMsg
subscriptions theAppModel =
    if remapingToolIsOpen theAppModel then
        GamepadPort.onBlob (Gamepad.Advanced.onBlob >> OnRemappingToolMsg)
    else
        GamepadPort.onBlob OnAnimationFrame
```

@docs Blob, animationFrameDelta, animationFrameTimestamp, getGamepads, unmappedGamepads


# User Mappings

@docs UserMappings , emptyUserMappings , userMappingsFromString , userMappingsToString, encodeUserMappings , userMappingsDecoder


# Remapping tool

@docs Model Msg , init , view , update , onBlob

-}

import Array exposing (Array)
import Dict exposing (Dict)
import Gamepad
    exposing
        ( Digital(..)
        , digitalToString
        , getIndex
        , isPressed
        )
import Gamepad.Private as Private
    exposing
        ( Gamepad(..)
        , GamepadFrame
        , Mapping
        , Origin(..)
        , OriginType(..)
        , boolToNumber
        )
import Gamepad.Translations exposing (Translation)
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (onClick)
import Json.Decode
import Json.Encode
import List.Extra
import Time exposing (Posix)


-- API ------------------------------------------------------------------------


{-| The Blob contains the raw gamepad data provided by the browser.

The whole point of this library is to transform the Blob into something
that is nice to use with Elm.

-}
type alias Blob =
    Private.Blob



-- API -----------------------------------------------------------------------


{-| This type contains all the custom mappings generated by the user
-}
type UserMappings
    = UserMappings
        { byIndexAndId : Dict ( Int, String ) Mapping
        , byId : Dict String Mapping
        }


{-| Making the `Origin` type available here would cause a circular dependency
pairsToMapping : List ( Origin, Digital ) -> Mapping
-}
pairsToMapping digitalToString pairs =
    pairs
        |> List.map (\( origin, digital ) -> ( digitalToString digital, origin ))
        |> Dict.fromList


getGamepadMapping : Mapping -> UserMappings -> GamepadFrame -> Maybe Mapping
getGamepadMapping standardMapping (UserMappings database) frame =
    case Dict.get ( frame.index, frame.id ) database.byIndexAndId of
        Just mapping ->
            Just mapping

        Nothing ->
            if frame.mapping == "standard" then
                Just standardMapping
            else
                Dict.get frame.id database.byId


allStandardMapping : Mapping
allStandardMapping =
    -- https://www.w3.org/TR/gamepad/#remapping
    [ ( A, Origin False Button 0 )
    , ( B, Origin False Button 1 )
    , ( X, Origin False Button 2 )
    , ( Y, Origin False Button 3 )

    --
    , ( Start, Origin False Button 9 )
    , ( Back, Origin False Button 8 )
    , ( Home, Origin False Button 16 )

    --
    , ( LeftStickLeft, Origin True Axis 0 )
    , ( LeftStickRight, Origin False Axis 0 )
    , ( LeftStickUp, Origin True Axis 1 )
    , ( LeftStickDown, Origin False Axis 1 )
    , ( LeftStickPress, Origin False Button 10 )
    , ( LeftBumper, Origin False Button 4 )
    , ( LeftTrigger, Origin False Button 6 )

    --
    , ( RightStickLeft, Origin True Axis 2 )
    , ( RightStickRight, Origin False Axis 2 )
    , ( RightStickUp, Origin True Axis 3 )
    , ( RightStickDown, Origin False Axis 3 )
    , ( RightStickPress, Origin False Button 11 )
    , ( RightBumper, Origin False Button 5 )
    , ( RightTrigger, Origin False Button 7 )

    --
    , ( DpadUp, Origin False Button 12 )
    , ( DpadDown, Origin False Button 13 )
    , ( DpadLeft, Origin False Button 14 )
    , ( DpadRight, Origin False Button 15 )
    ]
        |> List.map (\( a, b ) -> ( b, a ))
        |> pairsToMapping digitalToString



-- API -----------------------------------------------------------------------


{-| This function takes the user mappings and the latest blob and returns the
current states of all recognised gamepads.

Only recognised gamepads will be returned; use `haveUnmappedGamepads` to see
if there is any gamepad that can be configured.

    update msg model =
      case OnGamepad blob ->
        let
            isFiring = Gamepad.isPressed Gamepad.A

            playerFiringByIndex =
              blob
                |> Gamepad.getGamepads model.controls model.userMappings
                |> List.map (\gamepad -> Gamepad.getIndex isFiring gamepad))
                |> Dict.fromList
        in
            updateState playerFiringByIndex

-}
getGamepads : List ( String, Digital ) -> UserMappings -> Blob -> List Gamepad
getGamepads controls userMappings ( currentBlobFrame, previousBlobFrame, env ) =
    let
        isConfigured : String -> a -> Bool
        isConfigured digitalAsString origin =
            List.any (\( name, digital ) -> digitalToString digital == digitalAsString) controls

        standardMapping : Mapping
        standardMapping =
            Dict.filter isConfigured allStandardMapping

        getGamepad : GamepadFrame -> Maybe Gamepad
        getGamepad currentGamepadFrame =
            Maybe.map2 (\previousGamepadFrame mapping -> Gamepad mapping currentGamepadFrame previousGamepadFrame)
                (List.Extra.find (\prev -> prev.index == currentGamepadFrame.index) previousBlobFrame.gamepads)
                (getGamepadMapping standardMapping userMappings currentGamepadFrame)
    in
    List.filterMap getGamepad currentBlobFrame.gamepads



-- API -----------------------------------------------------------------------


{-| This function gives the time passed between the last browser animation
frame and the current one, in milliseconds.

It is the same value you get when using `Browser.Events.onAnimationFrameDelta`.

    update msg model =
      case msg of
        OnGamepad blob ->
          let
              -- Cap the elapsed time, in case the user hides the page and comes back later.
              deltaTimeInMilliseconds = min 200 (Gamepad.animationFrameDelta blob)

        ...

-}
animationFrameDelta : Blob -> Float
animationFrameDelta ( currentFrame, previousFrame, env ) =
    currentFrame.timestamp - previousFrame.timestamp



-- API -----------------------------------------------------------------------


{-| This function gives the Posix timestamp of the current browser animation
frame.

It is the same value you get when using `Browser.Events.onAnimationFrame`.

    update msg model =
      case msg of
        OnGamepad blob ->
          let
              posixTimestamp = Gamepad.animationFrame blob

        ...

-}
animationFrameTimestamp : Blob -> Time.Posix
animationFrameTimestamp ( currentFrame, previousFrame, env ) =
    Time.millisToPosix (floor currentFrame.timestamp)



-- API -----------------------------------------------------------------------


{-| [The Elm Architecture](https://guide.elm-lang.org/architecture/) `Msg` type
-}
type Msg
    = Noop
    | OnGamepad Blob
    | OnStartRemapping String Int
    | OnSkip Digital
    | OnCancel



-- API -----------------------------------------------------------------------


{-| The TEA Model, ie, the current state of the remap tool
-}
type Model
    = Model WrappedModel


type alias WrappedModel =
    { blob : Blob
    , maybeRemapping : Maybe Remapping
    , controls : List ( String, Digital )
    }


type alias Remapping =
    { id : String
    , index : Int
    , pairs : List ( Origin, Digital )
    , skipped : List Digital
    , waitingFor : WaitingFor
    }


initRemap : String -> Int -> Remapping
initRemap id index =
    { id = id
    , index = index
    , pairs = []
    , skipped = []
    , waitingFor = AllButtonsUp
    }


type alias Control =
    ( String, Digital )


type WaitingFor
    = AllButtonsUp
    | SomeButtonDown


nextUnmappedAction : List Control -> Remapping -> Maybe Control
nextUnmappedAction controls remapping =
    let
        mapped =
            List.map Tuple.second remapping.pairs ++ remapping.skipped

        needsMapping ( name, destination ) =
            List.all ((/=) destination) mapped
    in
    List.Extra.find needsMapping controls



-- API -----------------------------------------------------------------------


{-| This function returns the number of connected gamepads that cannot
be autoconfigured and are not in `UserMappings`.
If there are any, ask the user to remap them!
-}
unmappedGamepads : UserMappings -> Blob -> Int
unmappedGamepads userMappings ( currentBlobFrame, previousBlobFrame, env ) =
    currentBlobFrame.gamepads
        |> List.filter (\gamepadFrame -> getGamepadMapping allStandardMapping userMappings gamepadFrame == Nothing)
        |> List.length



-- API -----------------------------------------------------------------------


{-| [The Elm Architecture](https://guide.elm-lang.org/architecture/) `init`
-}
init : List ( String, Digital ) -> Model
init controls =
    Model
        { blob = Private.emptyBlob
        , maybeRemapping = Nothing
        , controls = controls
        }



-- API -----------------------------------------------------------------------


{-| [The Elm Architecture](https://guide.elm-lang.org/architecture/) `update`
function.

When a remapping is finished, it will return a function to update the user
mappings.

You will want to persist the new user mapping, otherwise the user will need
to remap every time tha page reloads.

-}
update : Msg -> Model -> ( Model, Maybe (UserMappings -> UserMappings) )
update msg (Model model) =
    Tuple.mapFirst Model <|
        case msg of
            Noop ->
                noCmd model

            OnGamepad blob ->
                updateOnGamepad { model | blob = blob }

            OnStartRemapping id index ->
                noCmd { model | maybeRemapping = Just (initRemap id index) }

            OnCancel ->
                noCmd { model | maybeRemapping = Nothing }

            OnSkip digital ->
                case model.maybeRemapping of
                    Nothing ->
                        noCmd model

                    Just remapping ->
                        let
                            ( maybeRemapping, maybeUpdate ) =
                                { remapping | skipped = digital :: remapping.skipped }
                                    |> maybeEndRemapping model.controls
                        in
                        ( { model | maybeRemapping = maybeRemapping }, maybeUpdate )


noCmd : a -> ( a, Maybe (UserMappings -> UserMappings) )
noCmd model =
    ( model, Nothing )


updateOnGamepad : WrappedModel -> ( WrappedModel, Maybe (UserMappings -> UserMappings) )
updateOnGamepad model =
    case model.maybeRemapping of
        Nothing ->
            noCmd model

        Just remapping ->
            updateRemapping remapping model
                |> Tuple.mapFirst (\r -> { model | maybeRemapping = r })


updateRemapping : Remapping -> WrappedModel -> ( Maybe Remapping, Maybe (UserMappings -> UserMappings) )
updateRemapping remapping model =
    case ( remapping.waitingFor, estimateOrigin model.blob remapping.index ) of
        ( AllButtonsUp, Nothing ) ->
            noCmd <| Just <| { remapping | waitingFor = SomeButtonDown }

        ( SomeButtonDown, Just origin ) ->
            case nextUnmappedAction model.controls remapping of
                Nothing ->
                    -- close remapper
                    noCmd Nothing

                Just ( name, destination ) ->
                    { remapping | waitingFor = AllButtonsUp }
                        |> insertPair origin destination
                        |> maybeEndRemapping model.controls

        _ ->
            noCmd <| Just <| remapping


maybeEndRemapping : List Control -> Remapping -> ( Maybe Remapping, Maybe (UserMappings -> UserMappings) )
maybeEndRemapping controls remapping =
    if nextUnmappedAction controls remapping /= Nothing then
        ( Just remapping, Nothing )
    else
        -- All controls have been mapped/skipped
        let
            updateFunction =
                pairsToUpdateUserMappings remapping.id remapping.index remapping.pairs

            -- If the gamepad is disabled, we can't wait for the user to press a
            -- button, so instead we close the remapper immediately.
            gamepadIsDisabled =
                remapping.pairs == []

            maybeRemapping =
                if gamepadIsDisabled then
                    Nothing
                else
                    Just remapping
        in
        ( maybeRemapping, Just updateFunction )


insertPair : Origin -> Digital -> Remapping -> Remapping
insertPair origin destination remapping =
    { remapping | pairs = ( origin, destination ) :: remapping.pairs }


pairsToUpdateUserMappings : String -> Int -> List ( Origin, Digital ) -> UserMappings -> UserMappings
pairsToUpdateUserMappings id index pairs (UserMappings database) =
    let
        mapping =
            pairsToMapping Gamepad.digitalToString pairs
    in
    UserMappings
        { byIndexAndId = Dict.insert ( index, id ) mapping database.byIndexAndId
        , byId = Dict.insert id mapping database.byId
        }



-- API -----------------------------------------------------------------------


{-| [The Elm Architecture](https://guide.elm-lang.org/architecture/) `view`
function.

You can use it as it is, or customise it with CSS: every element has its
own class name, all class names are prefixed with `elm-gamepad`.

The content will be translated according to `navigator.languages`.

-}
view : UserMappings -> Model -> Html Msg
view db (Model model) =
    let
        ( currentBlobFrame, previousBlobFrame, env ) =
            model.blob

        translation =
            Gamepad.Translations.pickTranslation env.languages Gamepad.Translations.allTranslations
    in
    div
        [ class "elm-gamepad" ]
        [ case model.maybeRemapping of
            Just remapping ->
                viewRemapping model.controls remapping translation

            Nothing ->
                case currentBlobFrame.gamepads of
                    [] ->
                        div
                            [ class "elm-gamepad-no-gamepads" ]
                            [ text translation.noGamepadsDetected ]

                    gamepadFrames ->
                        gamepadFrames
                            |> List.map (viewGamepadFrame model.controls db model.blob translation)
                            |> ul [ class "elm-gamepad-gamepad-list" ]
        , node "style"
            []
            [ text cssStyle ]
        ]


cssStyle =
    String.join "\n"
        [ ".elm-gamepad-mapping-unavailable { color: red; }"
        , ".elm-gamepad-mapping-available { color: green; }"
        , ".elm-gamepad-gamepad-index::before { content: 'Gamepad '; }"
        , ".elm-gamepad-gamepad-index::after { content: ': '; }"
        , ".elm-gamepad-remapping-skip { margin-top: 0.5em; }"
        , ".elm-gamepad-remapping-cancel { margin-top: 0.5em; }"
        ]


viewRemapping : List Control -> Remapping -> Translation -> Html Msg
viewRemapping controls remapping translation =
    let
        statusClass =
            class "elm-gamepad-remapping-tellsUserWhatIsHappening"

        instructionClass =
            class "elm-gamepad-remapping-tellsUserWhatToDo"
    in
    case nextUnmappedAction controls remapping of
        Nothing ->
            div
                [ class "elm-gamepad-remapping-complete" ]
                [ div
                    [ statusClass ]
                    [ text <| translation.remappingGamepadComplete remapping.index ]
                , div
                    [ instructionClass ]
                    [ text translation.pressAnyButtonToGoBack ]
                ]

        Just ( actionName, destination ) ->
            div
                [ class "elm-gamepad-remapping" ]
                [ div [ statusClass ]
                    [ text <| translation.remappingGamepad remapping.index ]
                , div [ instructionClass ]
                    [ text translation.press ]
                , div [ class "elm-gamepad-remapping-action-name" ]
                    [ text actionName ]
                , div [ class "elm-gamepad-remapping-skip" ]
                    [ button
                        [ onClick (OnSkip destination) ]
                        [ text translation.skipThisAction ]
                    ]
                , div [ class "elm-gamepad-remapping-cancel" ]
                    [ button
                        [ onClick OnCancel ]
                        [ text translation.cancelRemapping ]
                    ]
                ]


findIndex : Int -> List Gamepad -> Maybe Gamepad
findIndex index pads =
    List.Extra.find (\pad -> getIndex pad == index) pads


viewGamepadFrame : List Control -> UserMappings -> Blob -> Translation -> GamepadFrame -> Html Msg
viewGamepadFrame controls userMappings blob translation { id, index } =
    let
        maybeGamepad =
            findIndex index (getGamepads controls userMappings blob)

        maybeGamepadWithoutConfig =
            findIndex index (getGamepads controls emptyUserMappings blob)

        { symbolFace, symbolClass, buttonLabel, status, signal } =
            case maybeGamepad of
                Nothing ->
                    { symbolFace = "✘"
                    , symbolClass = "elm-gamepad-mapping-unavailable"
                    , buttonLabel = translation.map
                    , status = translation.needsMapping
                    , signal =
                        if estimateOrigin blob index == Nothing then
                            translation.idle
                        else
                            translation.receivingSignal
                    }

                Just gamepad ->
                    { symbolFace = "✔"
                    , symbolClass = "elm-gamepad-mapping-available"
                    , buttonLabel = translation.remap
                    , status =
                        if maybeGamepad == maybeGamepadWithoutConfig then
                            translation.standardMapping
                        else
                            translation.customMapping
                    , signal =
                        controls
                            |> List.Extra.find (Tuple.second >> isPressed gamepad)
                            |> Maybe.map Tuple.first
                            |> Maybe.withDefault translation.idle
                    }
    in
    li
        [ class "elm-gamepad-gamepad-list-item" ]
        [ span
            [ class "elm-gamepad-gamepad-index" ]
            [ text (String.fromInt index) ]
        , span
            [ class symbolClass ]
            [ text symbolFace ]
        , span
            [ class "elm-gamepad-mapping-state-text" ]
            [ text status ]
        , div
            [ class "elm-gamepad-current-action-text" ]
            [ text signal ]
        , button
            [ class "elm-gamepad-remap-button"
            , onClick (OnStartRemapping id index)
            ]
            [ text buttonLabel ]
        ]



-- API -----------------------------------------------------------------------


{-| This function turns a Blob into a Msg that you can feed to `update`.

This is how you pass the Blob information to the remapping tool, so it's very
important that you do so every time the remapping tool is open, it won't work
otherwise.

    subscriptions : Model -> Sub Msg
    subscriptions model =
        case model.state of
            RemappingTool _ ->
                GamepadPort.onBlob (Gamepad.Advanced.onBlob >> OnRemappingToolMsg)

            _ ->
                GamepadPort.onBlob OnAnimationFrame

Note: this function replaces the Elm Architecture `subscription` function
because I found that using a Msg constructor forces you to think about how
you want to consume gamepad inputs and animations while the remapping tool
is open.

In general, when the remapping tool is open you want to ignore all gamepad
information, but depending in your application you might want the animation
frame.

-}
onBlob : Blob -> Msg
onBlob =
    OnGamepad



-- Origin estimation -------------------------------------------------------------


buttonToEstimate : Int -> ( Bool, Float ) -> ( Origin, Float )
buttonToEstimate originIndex ( pressed, v ) =
    ( Origin False Button originIndex, boolToNumber pressed )


axisToEstimate : Int -> Float -> ( Origin, Float )
axisToEstimate originIndex v =
    ( Origin (v < 0) Axis originIndex, abs v )


estimateThreshold : ( Origin, Float ) -> Maybe Origin
estimateThreshold ( origin, confidence ) =
    if confidence < 0.5 then
        Nothing
    else
        Just origin


estimateOriginInFrame : GamepadFrame -> Maybe Origin
estimateOriginInFrame frame =
    let
        axesEstimates =
            Array.indexedMap axisToEstimate frame.axes

        buttonsEstimates =
            Array.indexedMap buttonToEstimate frame.buttons
    in
    Array.append axesEstimates buttonsEstimates
        |> Array.toList
        |> List.sortBy Tuple.second
        |> List.reverse
        |> List.head
        |> Maybe.andThen estimateThreshold


{-| This function guesses the Origin currently activated by the user.
-}
estimateOrigin : Blob -> Int -> Maybe Origin
estimateOrigin ( currentBlobFrame, previousBlobFrame, env ) index =
    currentBlobFrame.gamepads
        |> List.Extra.find (\pad -> pad.index == index)
        |> Maybe.andThen estimateOriginInFrame



-- User Mappings -------------------------------------------------------------


{-| UserMappings without any actual user mapping.

Gamepads that the browser recognises as "standard" will still be usable.

-}
emptyUserMappings : UserMappings
emptyUserMappings =
    UserMappings
        { byIndexAndId = Dict.empty
        , byId = Dict.empty
        }



-- API -----------------------------------------------------------------------


{-| Transforms UserMappings into a JSON string.

    saveUserMappingsToLocalStorageCmd =
        userMappings
            |> Gamepad.userMappingsToString
            |> LocalStoragePort.set 'gamepadUserMappings'

-}
userMappingsToString : UserMappings -> String
userMappingsToString userMappings =
    Json.Encode.encode 0 (encodeUserMappings userMappings)



-- API -----------------------------------------------------------------------


{-| Creates UserMappings from a JSON string.

    userMappings =
        flags.gamepadUserMappings
            |> Gamepad.userMappingsFromString
            |> Result.withDefault Gamepad.emptyUserMappings

-}
userMappingsFromString : String -> Result Json.Decode.Error UserMappings
userMappingsFromString asString =
    Json.Decode.decodeString userMappingsDecoder asString



-- API -----------------------------------------------------------------------


{-| Encodes a UserMappings into a JSON `Value`.
-}
encodeUserMappings : UserMappings -> Json.Encode.Value
encodeUserMappings (UserMappings database) =
    let
        encodeTuples : ( ( Int, String ), Mapping ) -> Json.Encode.Value
        encodeTuples ( ( index, id ), mapping ) =
            Json.Encode.object
                [ ( "index", Json.Encode.int index )
                , ( "id", Json.Encode.string id )
                , ( "mapping", encodeMapping mapping )
                ]

        encodeMapping : Mapping -> Json.Encode.Value
        encodeMapping mapping =
            Json.Encode.dict identity encodeOrigin mapping

        encodeOrigin : Origin -> Json.Encode.Value
        encodeOrigin (Origin isReverse type_ index) =
            Json.Encode.object
                [ ( "isReverse", Json.Encode.bool isReverse )
                , ( "type", encodeOriginType type_ )
                , ( "index", Json.Encode.int index )
                ]

        encodeOriginType : OriginType -> Json.Encode.Value
        encodeOriginType t =
            Json.Encode.string <|
                case t of
                    Axis ->
                        "axis"

                    Button ->
                        "button"
    in
    database.byIndexAndId
        |> Dict.toList
        |> Json.Encode.list encodeTuples



-- API -----------------------------------------------------------------------


{-| Decodes a UserMappings from a JSON `Value`.
-}
userMappingsDecoder : Json.Decode.Decoder UserMappings
userMappingsDecoder =
    let
        tuplesDecoder : Json.Decode.Decoder ( ( Int, String ), Mapping )
        tuplesDecoder =
            Json.Decode.map2 Tuple.pair
                keyDecoder
                (Json.Decode.field "mapping" (Json.Decode.dict originDecoder))

        keyDecoder : Json.Decode.Decoder ( Int, String )
        keyDecoder =
            Json.Decode.map2 Tuple.pair
                (Json.Decode.field "index" Json.Decode.int)
                (Json.Decode.field "id" Json.Decode.string)

        originDecoder : Json.Decode.Decoder Origin
        originDecoder =
            Json.Decode.map3 Origin
                (Json.Decode.field "isReverse" Json.Decode.bool)
                (Json.Decode.field "type" (Json.Decode.string |> Json.Decode.andThen stringToOriginType))
                (Json.Decode.field "index" Json.Decode.int)

        stringToOriginType : String -> Json.Decode.Decoder OriginType
        stringToOriginType s =
            case s of
                "axis" ->
                    Json.Decode.succeed Axis

                "button" ->
                    Json.Decode.succeed Button

                _ ->
                    Json.Decode.fail "unrecognised Origin Type"

        listToUserMappings : List ( ( Int, String ), Mapping ) -> UserMappings
        listToUserMappings listByIndexAndId =
            UserMappings
                { byIndexAndId = Dict.fromList listByIndexAndId
                , byId =
                    listByIndexAndId
                        |> List.map (Tuple.mapFirst Tuple.second)
                        |> Dict.fromList
                }
    in
    Json.Decode.list tuplesDecoder
        |> Json.Decode.map listToUserMappings
