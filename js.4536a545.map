{"version":3,"sources":["js/index.js"],"names":["setPixelsFromBatches","canvas","pixelBatches","canvasContext","getContext","imageData","getImageData","screenWidth","screenHeight","pixelIndex","batchIndex","pixelIndexInBatch","individualPixelMask","shift","pixelValue","Math","floor","pixelColor","colorMap","data","putImageData","document","addEventListener","event","e","key","preventDefault","app","Elm","Main","init","node","getElementById","ports","subscribe","elmData","canvasId","AudioContext","audioContext","window","webkitAudioContext","lastBufferEnds","queueAudioSamples","length","buffer","createBuffer","sampleRate","leftChannel","getChannelData","rightChannel","i","bufferSource","createBufferSource","connect","destination","currentBufferStart","currentTime","max","start"],"mappings":";;;AAmFA,aAnFA,IAAA,EAAA,QAAA,mBAiDA,SAASA,EAAsBC,EAAQC,GAIhC,IAHCC,IAAAA,EAAgBF,EAAOG,WAAW,MAClCC,EAAYF,EAAcG,aAAa,EAAG,EAAGC,EAAaC,GAEvDC,EAAa,EAAGA,EAAaF,EAAcC,EAAcC,IAAc,CACxEC,IACAC,EAAoBF,EAAa,GAEjCG,EAAsB,aAA4D,EAApBD,EAC9DE,EAAQ,GAA0B,EAApBF,EAEdG,GAAcZ,EANDa,KAAKC,MAAMP,EAAa,KAMIG,KAAyBC,EAClEI,EAAaC,EAASJ,GAE5BT,EAAUc,KAAkB,EAAbV,GAAkBQ,EAAW,GAC5CZ,EAAUc,KAAkB,EAAbV,EAAiB,GAAKQ,EAAW,GAChDZ,EAAUc,KAAkB,EAAbV,EAAiB,GAAKQ,EAAW,GAChDZ,EAAUc,KAAkB,EAAbV,EAAiB,GAAK,IAGvCN,EAAciB,aAAaf,EAAW,EAAG,GAnE3CgB,SAASC,iBAAiB,mBAAoB,SAAUC,GAItDF,SAASC,iBAAiB,UAAW,SAAUE,GAC/B,cAAVA,EAAEC,KAAiC,YAAVD,EAAEC,KAA+B,cAAVD,EAAEC,KAAiC,eAAVD,EAAEC,KAC7ED,EAAEE,mBAIAC,IAAAA,EAAMC,EAAIC,IAAAA,KAAKC,KAAK,CACxBC,KAAMV,SAASW,eAAe,YAGhCL,EAAIM,MAAMjC,qBAAqBkC,UAAU,SAAUC,GAGjDnC,EAFeqB,SAASW,eAAeG,EAAQC,UAElBD,EAAQjC,gBAGjCmC,IACAC,EAAe,IADAC,OAAOF,cAAgBE,OAAOC,oBAE/CC,EAAiB,EAErBd,EAAIM,MAAMS,kBAAkBR,UAAU,SAAUC,GAC1CA,GAAAA,EAAQQ,OAAS,EAAG,CAKjB,IAJCC,IAAAA,EAASN,EAAaO,aAAa,EAAGV,EAAQQ,OAAQG,GACtDC,EAAcH,EAAOI,eAAe,GACpCC,EAAeL,EAAOI,eAAe,GAElCE,EAAI,EAAGA,EAAIf,EAAQQ,OAAQO,IAClCH,EAAYG,GAAKf,EAAQA,EAAQQ,OAAS,EAAIO,GAAG,GACjDD,EAAaC,GAAKf,EAAQA,EAAQQ,OAAS,EAAIO,GAAG,GAG9CC,IAAAA,EAAeb,EAAac,qBAClCD,EAAaP,OAASA,EACtBO,EAAaE,QAAQf,EAAagB,aAE5BC,IAAAA,EAAqBjB,EAAakB,YAAczC,KAAK0C,IAAI,EAAGhB,EAAiBH,EAAakB,aAChGf,EAAiBc,EAAsBpB,EAAQQ,OAASG,EAExDK,EAAaO,MAAMH,QA4BzB,IAAMhD,EAAc,IAEdC,EAAe,IAEfU,EAAW,CACf,CAAC,IAAK,IAAK,IACX,CAAC,IAAK,IAAK,IACX,CAAC,GAAI,GAAI,IACT,CAAC,GAAI,GAAI,KAGL4B,EAAa","file":"js.4536a545.map","sourceRoot":"../src","sourcesContent":["import { Elm } from '../elm/Main.elm'\n\ndocument.addEventListener('DOMContentLoaded', function (event) {\n  // There is currently no way to prevent default for Browser.Events in Elm. I took the pragmatic approach here to just prevent default\n  // on the error keys whose default is problematic due to the fact they might scroll the viewport while playing. This should be replaced as\n  // soon as we can prevent default for Browser.Events.\n  document.addEventListener('keydown', function (e) {\n    if (e.key === 'ArrowDown' || e.key === 'ArrowUp' || e.key === 'ArrowLeft' || e.key === 'ArrowRight') {\n      e.preventDefault()\n    }\n  })\n\n  const app = Elm.Main.init({\n    node: document.getElementById('elmboy')\n  })\n\n  app.ports.setPixelsFromBatches.subscribe(function (elmData) {\n    const canvas = document.getElementById(elmData.canvasId)\n\n    setPixelsFromBatches(canvas, elmData.pixelBatches)\n  })\n\n  const AudioContext = window.AudioContext || window.webkitAudioContext\n  const audioContext = new AudioContext()\n  let lastBufferEnds = 0\n\n  app.ports.queueAudioSamples.subscribe(function (elmData) {\n    if (elmData.length > 0) {\n      const buffer = audioContext.createBuffer(2, elmData.length, sampleRate)\n      const leftChannel = buffer.getChannelData(0)\n      const rightChannel = buffer.getChannelData(1)\n\n      for (let i = 0; i < elmData.length; i++) {\n        leftChannel[i] = elmData[elmData.length - 1 - i][0]\n        rightChannel[i] = elmData[elmData.length - 1 - i][1]\n      }\n\n      const bufferSource = audioContext.createBufferSource()\n      bufferSource.buffer = buffer\n      bufferSource.connect(audioContext.destination)\n\n      const currentBufferStart = audioContext.currentTime + Math.max(0, lastBufferEnds - audioContext.currentTime)\n      lastBufferEnds = currentBufferStart + (elmData.length / sampleRate)\n\n      bufferSource.start(currentBufferStart)\n    }\n  })\n})\n\nfunction setPixelsFromBatches (canvas, pixelBatches) {\n  const canvasContext = canvas.getContext('2d')\n  const imageData = canvasContext.getImageData(0, 0, screenWidth, screenHeight)\n\n  for (let pixelIndex = 0; pixelIndex < screenWidth * screenHeight; pixelIndex++) {\n    const batchIndex = Math.floor(pixelIndex / 16)\n    const pixelIndexInBatch = pixelIndex % 16\n\n    const individualPixelMask = 0b11000000000000000000000000000000 >>> (pixelIndexInBatch * 2)\n    const shift = 30 - (pixelIndexInBatch * 2)\n\n    const pixelValue = (pixelBatches[batchIndex] & individualPixelMask) >>> shift\n    const pixelColor = colorMap[pixelValue]\n\n    imageData.data[pixelIndex * 4] = pixelColor[0]\n    imageData.data[pixelIndex * 4 + 1] = pixelColor[1]\n    imageData.data[pixelIndex * 4 + 2] = pixelColor[2]\n    imageData.data[pixelIndex * 4 + 3] = 255\n  }\n\n  canvasContext.putImageData(imageData, 0, 0)\n}\n\nconst screenWidth = 160\n\nconst screenHeight = 144\n\nconst colorMap = [\n  [155, 188, 15],\n  [139, 172, 15],\n  [48, 98, 48],\n  [15, 56, 15]\n]\n\nconst sampleRate = 44100\n"]}